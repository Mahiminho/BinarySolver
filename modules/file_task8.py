class module_task8:
    def task8(num):
        print("Тема: 8. ДОДАТИ У ДОПОВНЯЛЬНОМУ ТА ОБЕРНЕНОМУ КОДАХ ДВІЙКОВІ ЧИСЛА У ФОРМАТІ З ФІКСОВАНОЮ КОМОЮ:")
        print("\nПОПЕРЕДЖЕННЯ: Увага! У цьому завданні у квадаратних дужках позначається, у якому коді подане число:\nпр - прямий;\nоб - обернений;\nдоп - доповняльний.\nКвадратних дужок переписувати не потрібно, просто вкажіть тип двійкового коду трохи меншими буквами.\n")
        num = num.split(" ") # розбиваю задану юзером строку на два числа
        a = num[0]
        b = num[1]

        print("Задані числа:")
        print(a)
        print(b)
        print("")

        # РОЗБИВАЮ ОБИДВА ЧИСЛА НА ДВІ ЧАСТИНИ ПО КОМІ, ЗАЛИШАЮ ЛИШЕ САМЕ ЧИСЛО (ТОБТО ТЕ, ЩО ПІСЛЯ КОМИ)
        a1 = a.split(",")
        b1 = b.split(",")
        a2 = a1[1]
        b2 = b1[1]

        print("Задані числа у прямому коді:")
        print("A[пр] = 11," + a2)
        print("B[пр] = 00," + b2)
        print("")

        # ОБЕРТАЮ ЧИСЛА (ЗАМІНЯЮ 1 НА 0 І НАВПАКИ У ЦИКЛІ), А ДАЛІ СКЛАДАЮ ДОКУПИ (ЦЕ ВСЕ ЛИШЕ ДЛЯ ПЕРШОГО ЧИСЛА, ДРУГЕ НЕ ЧІПАЮ)
        a3 = []
        i = 0
        while i < len(a2):
            if a2[i] == "0":
                a3.append("1")
            else:
                a3.append("0")
            i += 1

        b3 = b2
        a4 = ''.join(a3)
        b4 = ''.join(b3)

        print("Задані числа у оберненому коді:")
        print("A[об] = 11," + a4)
        print("B[об] = 00," + b4)
        print("")

        # ПЕРЕТВОРЮЮ ЧИСЛА У ДОПОВНЯЛЬНИЙ КОД (ДО ПЕРШОГО ЧИСЛА ДОДАЮ ОДИНИЦЮ, ТА Й ВСЕ) (ЦЕ ВСЕ ЛИШЕ ДЛЯ ПЕРШОГО ЧИСЛА, ДРУГЕ НЕ ЧІПАЮ)
        sum = int(a4, 2) + int('1', 2)
        a5 = bin(sum)[2:]
        if len(a5) < 6:
            a5 = (6 - len(a5)) * "0" + a5
        b5 = b4

        print("Задані числа у доповняльному коді:")
        print("A[доп] = 11," + a5)
        print("B[доп] = 00," + b5)
        print("")



        a6 = "11" + a4
        b6 = "00" + b4
        sum = int(a6, 2) + int(b6, 2) # додаю числа в оберених кодах
        half_res = bin(sum)[2:]

        n = len(half_res) - 6 # рахую скільки символів лишилось до коми (3 - якщо 110, 2 - якщо 11)
        full_res = half_res[n:] # відділяю лише саме число

        print("1) Додавання чисел у обернених кодах:")
        print("A[об] + B[об] = C[об]")
        print("")
        print(" 11," + a4)
        print("+")
        print(" 00," + b4)
        print("__________")
        if n == 2: # в залежності від символів до коми виводжу відповідь
            print(" 11," + full_res)
        else:  # протилежний варіант
            print("110," + full_res)
        print("")
        print("C[об] = 11," + full_res)
        full_res1 = []
        i = 0
        while i < len(full_res): # перевід результату з оберненого коду в прямий
            if full_res[i] == "0":
                full_res1.append("1")
            else:
                full_res1.append("0")
            i += 1
        full_res1 = ''.join(full_res1) # складання результату докупи
        print("C[пр] = 11," + full_res1)
        print("")



        # ВСІ ТІ САМІ ДІЇ ДЛЯ ДОДАВАННЯ В ДОПОВНЯЛЬНИХ КОДАХ, АЛЕ ВЖЕ НЕ РАХУЮ РЕЗУЛЬТАТ В ПРЯМОМУ КОДІ, БО ВІН ТАКИЙ САМИЙ, ЯК І ВИЩЕ
        a7 = "11" + a5
        b7 = "00" + b5
        sum = int(a7, 2) + int(b7, 2)
        half_res = bin(sum)[2:]

        n = len(half_res) - 6
        full_res = half_res[n:]

        print("2) Додавання чисел у доповняльних кодах:")
        print("A[доп] + B[доп] = C[доп]")
        print("")
        print(" 11," + a5)
        print("+")
        print(" 00," + b5)
        print("__________")
        if n == 2:
            print(" 11," + full_res)
        else:
            print("110," + full_res)
        print("")
        print("C[доп] = 11," + full_res)
        print("C[пр] = 11," + full_res1)
        print("\n\n")